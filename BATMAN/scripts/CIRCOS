#!/bin/bash

#SBATCH --partition=defq
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=32
#SBATCH --mem=128g
#SBATCH --time=48:00:00
#SBATCH --job-name=circos
#SBATCH --output=/gpfs01/home/mbxas26/CNS/circos/logs/slurm-%x-%j.out
#SBATCH --error=/gpfs01/home/mbxas26/CNS/circos/logs/slurm-%x-%j.err
#SBATCH --mail-type=ALL
#SBATCH --mail-user=mbxas26@exmail.nottingham.ac.uk

# Load environment
source $HOME/.bash_profile

conda activate circos


import math, argparse
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use("Agg")  # headless safe
import matplotlib.pyplot as plt

# Genome layout
CHROMS = [f"chr{i}" for i in range(1,23)] + ["chrX","chrY"]
HG38 = {
 "chr1":248956422,"chr2":242193529,"chr3":198295559,"chr4":190214555,
 "chr5":181538259,"chr6":170805979,"chr7":159345973,"chr8":145138636,
 "chr9":138394717,"chr10":133797422,"chr11":135086622,"chr12":133275309,
 "chr13":114364328,"chr14":107043718,"chr15":101991189,"chr16":90338345,
 "chr17":83257441,"chr18":80373285,"chr19":58617616,"chr20":64444167,
 "chr21":46709983,"chr22":50818468,"chrX":156040895,"chrY":57227415
}

def angles():
    N = len(CHROMS)
    angle_per_chr = 2*math.pi/N
    start = {CHROMS[i]: i*angle_per_chr for i in range(N)}
    return start, angle_per_chr

def pos_to_angle(chr_name, pos, start_angle, angle_per_chr):
    L = HG38.get(chr_name, 1)
    frac = min(max(float(pos)/L, 0.0), 1.0)
    return start_angle[chr_name] + frac*angle_per_chr

def qbezier(P0,P1,P2,steps=160):
    t = np.linspace(0.0,1.0,steps)
    return ((1-t)**2)[:,None]*np.array(P0,float) + (2*(1-t)*t)[:,None]*np.array(P1,float) + (t**2)[:,None]*np.array(P2,float)

def make_chord(ax, a0, a1, r0=1.0, rctrl=0.45, lw=2.0, ls='-', alpha=0.9, color=None):
    P0 = (r0*np.cos(a0), r0*np.sin(a0))
    P2 = (r0*np.cos(a1), r0*np.sin(a1))
    mid = math.atan2((P0[1]+P2[1])/2.0, (P0[0]+P2[0])/2.0)
    Pc = (rctrl*np.cos(mid), rctrl*np.sin(mid))
    pts = qbezier(P0,Pc,P2,steps=160)
    ax.plot(pts[:,0], pts[:,1], lw=lw, ls=ls, alpha=alpha, color=color, zorder=3)

def draw_colored_ideogram(ax, r=1.0, label_r=1.16):
    start_angle, angle_per_chr = angles()
    # outer thin gray ring
    th = np.linspace(0, 2*math.pi, 720)
    ax.plot(r*np.cos(th), r*np.sin(th), lw=1.0, color="#BBBBBB", zorder=1)
    # colorful arcs per chromosome
    cmap = plt.get_cmap("tab20", len(CHROMS))
    for i, c in enumerate(CHROMS):
        t = np.linspace(start_angle[c], start_angle[c]+angle_per_chr, 80)
        ax.plot(r*np.cos(t), r*np.sin(t), lw=6, solid_capstyle="butt", color=cmap(i), zorder=2)
        lm = start_angle[c] + angle_per_chr/2
        ax.text(r*label_r*np.cos(lm), r*label_r*np.sin(lm), c.replace("chr",""),
                ha="center", va="center", fontsize=9, rotation=np.degrees(lm)+90, rotation_mode='anchor')
    return start_angle, angle_per_chr

# Data (embedded) 
def mid(a,b): return int(round((a+b)/2))

def embedded_batman_df():
    rows = []
    def add(svtype, chrA,posA, chrB,posB, support, sv_id):
        rows.append(dict(sample="BATMAN", svtype=svtype, chrA=chrA, posA=int(posA),
                         chrB=chrB, posB=int(posB), support=int(support) if support is not None else 0, id=sv_id))
    # Translocations 1–23
    for (A,a,B,b,s,ID) in [
      ("chr10",66756319,"chr7",61056482,19,"SV01"),
      ("chr10",73317097,"chr14",20567943,41,"SV02"),
      ("chr10",81999375,"chr9",27592879,12,"SV03"),
      ("chr10",81999397,"chr9",27598297,39,"SV04"),
      ("chr10",112665036,"chr12",91088442,9,"SV05"),
      ("chr11",179961,"chr9",138231506,7,"SV06"),
      ("chr11",11082352,"chr5",38490497,20,"SV07"),
      ("chr11",11082369,"chr5",38490497,11,"SV08"),
      ("chr13",69666795,"chr9",24361048,7,"SV09"),
      ("chr14",23870090,"chr17",21102598,81,"SV10"),
      ("chr14",104806797,"chr17",80313957,3,"SV11"),
      ("chr17",58371483,"chr6",45066877,4,"SV12"),
      ("chr17",58371505,"chr6",45077408,8,"SV13"),
      ("chr17",58827561,"chr3",152091737,7,"SV14"),
      ("chr3",152094457,"chr17",58827573,16,"SV15"),
      ("chr3",183907187,"chr14",23870636,21,"SV16"),
      ("chr4",76022671,"chr9",34808088,9,"SV17"),
      ("chr5",21207623,"chr4",79966938,2,"SV18"),
      ("chr5",38490462,"chr11",11082369,26,"SV19"),
      ("chr5",38490506,"chr11",11074609,5,"SV20"),
      ("chr8",131381512,"chr10",64007306,11,"SV21"),
      ("chrY",56854863,"chr21",10455290,22,"SV22"),
      ("chrY",56887676,"chr22",10739604,4,"SV23"),
    ]:
        add("TRA", A,a,B,b,s,ID)

    # Duplication-labelled multi-partner mappings (midpoints for ranges)
    add("DUP","chr2", mid(90379785,90389949), "chr16", mid(46416619,46417701), 0, "SV24a")
    add("DUP","chr2", mid(90390637,90398814), "chr5",  mid(107573763,107579835), 0, "SV24b")
    add("DUP","chr2", mid(90380595,90402511), "chr1",  mid(125154112,125155698), 0, "SV24c")
    add("DUP","chr2", mid(90390744,90402511), "chr7",  mid(60935497,60937627), 0, "SV24d")
    add("DUP","chr2", mid(90394844,90397315), "chr8",  mid(107967236,107974092), 0, "SV24e")
    add("DUP","chr19",mid(43326712,43329234), "chr20", mid(62363510,62374623), 0, "SV25")

    # Inversion (two links from the same read)
    add("INV","chr5",159132835,"chr5", mid(159200519,159229857), 0, "SV26a")
    add("INV","chr5",159132835,"chr7", mid(142711104,142714732), 0, "SV26b")

    # Deletion-linked mapping
    add("DEL","chr12",8405904,"chr2", mid(158884980,158887289), 0, "SV27")

    return pd.DataFrame(rows)

# Plot routine 
def lw_from_support_factory(supports):
    pos = supports[supports>0]
    if len(pos) == 0:
        s_min, s_max = 0.0, 1.0
    else:
        s_min, s_max = float(pos.min()), float(pos.max())
    def f(s):
        if s <= 0: return 1.3
        s_norm = (np.sqrt(s)-np.sqrt(s_min))/(np.sqrt(s_max)-np.sqrt(s_min)+1e-9)
        return 1.3 + (5.5-1.3)*float(np.clip(s_norm,0,1))
    return f, (int(s_min), int(np.median(pos)) if len(pos)>0 else 1, int(s_max))

def make_plot(df, title, out_prefix):
    df = df[(df["chrA"].isin(CHROMS)) & (df["chrB"].isin(CHROMS))].copy()
    df["support"] = pd.to_numeric(df["support"], errors="coerce").fillna(0)
    lw_from_support, ex_vals = lw_from_support_factory(df["support"].values)

    fig = plt.figure(figsize=(11,11), dpi=300)
    ax = plt.gca(); ax.set_aspect('equal'); ax.axis('off')
    start_angle, angle_per_chr = draw_colored_ideogram(ax, r=1.0, label_r=1.12)

    style_map = {"TRA":"-","INV":"--","DEL":":","DUP":"-."}

    # Draw chords grouped by svtype (back-to-front layering)
    for svtype in ["DEL","DUP","INV","TRA"]:
        sub = df[df["svtype"].str.upper()==svtype]
        for _, r in sub.iterrows():
            a0 = pos_to_angle(r["chrA"], r["posA"], start_angle, angle_per_chr)
            a1 = pos_to_angle(r["chrB"], r["posB"], start_angle, angle_per_chr)
            make_chord(ax, a0, a1, lw=lw_from_support(r["support"]),
                       ls=style_map.get(svtype,"-"), alpha=0.9)

    ax.text(0, 1.34, title, ha="center", va="center", fontsize=18, weight="bold")

    # Legends (boxed, inside canvas)
    handles_sv = [
        plt.Line2D([0],[0], lw=3, ls=style_map["TRA"], label="Translocation (TRA)"),
        plt.Line2D([0],[0], lw=3, ls=style_map["INV"], label="Inversion (INV)"),
        plt.Line2D([0],[0], lw=3, ls=style_map["DEL"], label="Deletion (DEL)"),
        plt.Line2D([0],[0], lw=3, ls=style_map["DUP"], label="Duplication (DUP)"),
    ]
    leg1 = ax.legend(handles=handles_sv, loc="lower left", bbox_to_anchor=(0.02, 0.02),
                     frameon=True, facecolor="white", edgecolor="black",
                     title="SV type (line style)", fontsize=11, title_fontsize=12)
    ax.add_artist(leg1)

    # Support legend
    if sum(df["support"]>0) > 0:
        ex = sorted({v for v in ex_vals})
        h2 = [plt.Line2D([0],[0], lw=lw_from_support(v), ls='-') for v in ex]
        l2 = [f"support ≈ {v}" for v in ex]
        leg2 = ax.legend(handles=h2, labels=l2, loc="lower right", bbox_to_anchor=(0.98, 0.02),
                         frameon=True, facecolor="white", edgecolor="black",
                         title="Read support (line width)", fontsize=11, title_fontsize=12)
        ax.add_artist(leg2)

    plt.tight_layout()
    plt.savefig(f"{out_prefix}.png", dpi=300, bbox_inches="tight")
    plt.savefig(f"{out_prefix}.pdf", bbox_inches="tight")
    plt.close(fig)

# Main 
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--csv", help="Optional: read SVs from CSV with columns svtype,chrA,posA,chrB,posB,support,id")
    ap.add_argument("--out_prefix", default="chromosomal_map_BATMAN")
    ap.add_argument("--title", default="Chromosomal map (BATMAN)")
    args = ap.parse_args()

    if args.csv:
        df = pd.read_csv(args.csv)
    else:
        df = embedded_batman_df()

    make_plot(df, args.title, args.out_prefix)

if __name__ == "__main__":
    main()

# Deactivate environment after run
conda deactivate
